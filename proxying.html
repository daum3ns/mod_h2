<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <title>h2 proxying</title>
                
        <link rel="stylesheet" href="stylesheets/styles.css">
        <link rel="stylesheet" href="stylesheets/pygment_trac.css">
        <link rel="stylesheet" href="stylesheets/mod_h2.css">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="wrapper">
            <div class="backlogo" style="background-image: none; padding-top: 0; top: 10em;">
            </div>
            <header>
                <h1>mod_h[ttp]2</h1>
                <p>HTTP/2 for <a href="https://httpd.apache.org/download.cgi">Apache httpd</a></p>
            </header>
            <section>
                <h1>
                    <a class="anchor" href="#top" aria-hidden="true"><span class="octicon octicon-link"></span></a>
                    h2 proxying
                </h1>
                
                <p>
                    With the v1.14.x versions of mod-h2, a drastic change was applied to the <code>mod_proxy_http2</code>
                    module. The trigger was <a hef="https://bz.apache.org/bugzilla/show_bug.cgi?id=63170">PR 63170</a>
                    on the Apache bugzilla. This caused me to reconsider my implementation.
                </p>
                <p>
                    The good news is that the inappropriate behaviour of <code>mod_proxy_http2</code> has been
                    fixed and the changes will become part of the next Apache httpd release! So, if you ever
                    considered running HTTP/2 between Apache and a backend, the v1.14.1 and later is a good version
                    to use.
                </p>
                <p>
                    For the more technical depth oriented: the former implementation was a bit ambitious and 
                    overconfident. To explain that, I need to go into more detail about <code>mod_proxy</code>
                    and siblings behaviour.
                </p>
                <p>
                    <code>mod_proxy</code> is a handler for a request, just like file system based lookups
                    is another one. When you define your <code>ProxyPass</code> and such configuration, you
                    specify where the proxy module should take over. <code>mod_proxy</code> then passes the
                    request on to the sub-module configured, usually <code>mod_proxy_http</code> or, as here,
                    <code>mod_proxy_http2</code>.  
                </p>
                <p>
                    This sub-module then makes the request to the backend server, using <em>its</em>
                    protocol. It does not matter how the request was done on the incoming connection. Which
                    is nice, because you can offer HTTP/2 to clients while processing responses on a backend
                    that does not even talk HTTP/2.
                </p>
                <p>
                    Since all this started with the HTTP/1.x processing in mind, the proxy modules do
                    one request at a time, return the response and are done - until called again for
                    another request. This fits perfectly to HTTP/1 connections. However, h2 requests
                    can work in parallel which is generally more efficient.
                </p>
                <p>
                    And this is what <code>mod_proxy_http2</code> tried to enable. It was gathering
                    incoming requests from the client connection onto a single connection to the backend.
                    Which can make for some nice savings on your forward facing Apache server. It could
                    make better use of its worker threads, serving more connections in parallel.
                </p>
                <p>
                    But the implementation of <code>mod_proxy_http2</code> simply was not good enough.
                    After attempts to fix concurrency problems, PR 63170 made me realize that the 
                    design inherently suffered from lack of flow control. Which caused unreasonably
                    memory demands when clients turned up the heat. 
                </p>
                <p>
                    So, in v1.14.0 I threw out all the super-parallel stuff and <code>mod_proxy_http2</code>
                    is now working similar to <code>mod_proxy_http</code>. It does one request at a time
                    on a connection, serves the complete answer, frees resources and takes the next
                    request. 
                </p>
                <p>
                    Are there still advantages to be had when using it? I think so:
                    <ol>
                        <li>Header compression saves quite some bytes. Remember: the h2 connection is
                        reused. Repeated headers become very efficient to transfer.</li>
                        <li>Aborted requests are handled more gracefully and preserve the
                        connection. If a large request needs to be aborted (for example, as the
                        client closed its connection or RESETs a stream), a HTTP/2 connection is 
                        cleaned up very easily and remains usable. In HTTP/1 it would need to
                        be either closed or all data needed reading only to throw it away.</li>
                    </ol>
                </p>
                <p>
                    Still, the previous goal of sharing a h2 backend connection for many requests
                    in parallel is good. I am still thinking about how a new approach to this might
                    look - taking the lessons learned into account. For now, I hope the new
                    <code>mod_proxy_http2</code> serves you well. 
                </p>

                
                <p>MÃ¼nster, 15.03.2019,</p>
                
                <p>Stefan Eissing, greenbytes GmbH</p>

                <p>Copyright (C) 2019 greenbytes GmbH</p>
                <p>Copying and distribution of this file, with or without modification,
                are permitted in any medium without royalty provided the copyright
                notice and this notice are preserved.  This file is offered as-is,
                without warranty of any kind. See LICENSE for details.
                </p>
                
            </section>
            <footer>
                <p>This project is maintained by <a href="https://github.com/icing">icing</a></p>
                <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
        
    </body>
</html>
